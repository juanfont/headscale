{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to headscale","text":"<p>Headscale is an open source, self-hosted implementation of the Tailscale control server.</p> <p>This page contains the documentation for the latest version of headscale. Please also check our FAQ.</p> <p>Join our Discord server for a chat and community support.</p>"},{"location":"#design-goal","title":"Design goal","text":"<p>Headscale aims to implement a self-hosted, open source alternative to the Tailscale control server. Headscale's goal is to provide self-hosters and hobbyists with an open-source server they can use for their projects and labs. It implements a narrow scope, a single Tailscale network (tailnet), suitable for a personal use, or a small open-source organisation.</p>"},{"location":"#supporting-headscale","title":"Supporting headscale","text":"<p>Please see Sponsor for more information.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Headscale is \"Open Source, acknowledged contribution\", this means that any contribution will have to be discussed with the Maintainers before being submitted.</p> <p>Please see Contributing for more information.</p>"},{"location":"#about","title":"About","text":"<p>Headscale is maintained by Kristoffer Dalby and Juan Font.</p>"},{"location":"about/clients/","title":"Client and operating system support","text":"<p>We aim to support the last 10 releases of the Tailscale client on all provided operating systems and platforms. Some platforms might require additional configuration to connect with headscale.</p> OS Supports headscale Linux Yes OpenBSD Yes FreeBSD Yes Windows Yes (see docs and <code>/windows</code> on your headscale for more information) Android Yes (see docs for more information) macOS Yes (see docs and <code>/apple</code> on your headscale for more information) iOS Yes (see docs and <code>/apple</code> on your headscale for more information) tvOS Yes (see docs and <code>/apple</code> on your headscale for more information)"},{"location":"about/contributing/","title":"Contributing","text":"<p>Headscale is \"Open Source, acknowledged contribution\", this means that any contribution will have to be discussed with the maintainers before being added to the project. This model has been chosen to reduce the risk of burnout by limiting the maintenance overhead of reviewing and validating third-party code.</p>"},{"location":"about/contributing/#why-do-we-have-this-model","title":"Why do we have this model?","text":"<p>Headscale has a small maintainer team that tries to balance working on the project, fixing bugs and reviewing contributions.</p> <p>When we work on issues ourselves, we develop first hand knowledge of the code and it makes it possible for us to maintain and own the code as the project develops.</p> <p>Code contributions are seen as a positive thing. People enjoy and engage with our project, but it also comes with some challenges; we have to understand the code, we have to understand the feature, we might have to become familiar with external libraries or services and we think about security implications. All those steps are required during the reviewing process. After the code has been merged, the feature has to be maintained. Any changes reliant on external services must be updated and expanded accordingly.</p> <p>The review and day-1 maintenance adds a significant burden on the maintainers. Often we hope that the contributor will help out, but we found that most of the time, they disappear after their new feature was added.</p> <p>This means that when someone contributes, we are mostly happy about it, but we do have to run it through a series of checks to establish if we actually can maintain this feature.</p>"},{"location":"about/contributing/#what-do-we-require","title":"What do we require?","text":"<p>A general description is provided here and an explicit list is provided in our pull request template.</p> <p>All new features have to start out with a design document, which should be discussed on the issue tracker (not discord). It should include a use case for the feature, how it can be implemented, who will implement it and a plan for maintaining it.</p> <p>All features have to be end-to-end tested (integration tests) and have good unit test coverage to ensure that they work as expected. This will also ensure that the feature continues to work as expected over time. If a change cannot be tested, a strong case for why this is not possible needs to be presented.</p> <p>The contributor should help to maintain the feature over time. In case the feature is not maintained probably, the maintainers reserve themselves the right to remove features they redeem as unmaintainable. This should help to improve the quality of the software and keep it in a maintainable state.</p>"},{"location":"about/contributing/#bug-fixes","title":"Bug fixes","text":"<p>Headscale is open to code contributions for bug fixes without discussion.</p>"},{"location":"about/contributing/#documentation","title":"Documentation","text":"<p>If you find mistakes in the documentation, please submit a fix to the documentation.</p>"},{"location":"about/faq/","title":"Frequently Asked Questions","text":""},{"location":"about/faq/#what-is-the-design-goal-of-headscale","title":"What is the design goal of headscale?","text":"<p>Headscale aims to implement a self-hosted, open source alternative to the Tailscale control server. Headscale's goal is to provide self-hosters and hobbyists with an open-source server they can use for their projects and labs. It implements a narrow scope, a single Tailscale network (tailnet), suitable for a personal use, or a small open-source organisation.</p>"},{"location":"about/faq/#how-can-i-contribute","title":"How can I contribute?","text":"<p>Headscale is \"Open Source, acknowledged contribution\", this means that any contribution will have to be discussed with the Maintainers before being submitted.</p> <p>Please see Contributing for more information.</p>"},{"location":"about/faq/#why-is-acknowledged-contribution-the-chosen-model","title":"Why is 'acknowledged contribution' the chosen model?","text":"<p>Both maintainers have full-time jobs and families, and we want to avoid burnout. We also want to avoid frustration from contributors when their PRs are not accepted.</p> <p>We are more than happy to exchange emails, or to have dedicated calls before a PR is submitted.</p>"},{"location":"about/faq/#whenwhy-is-feature-x-going-to-be-implemented","title":"When/Why is Feature X going to be implemented?","text":"<p>We don't know. We might be working on it. If you're interested in contributing, please post a feature request about it.</p> <p>Please be aware that there are a number of reasons why we might not accept specific contributions:</p> <ul> <li>It is not possible to implement the feature in a way that makes sense in a self-hosted environment.</li> <li>Given that we are reverse-engineering Tailscale to satisfy our own curiosity, we might be interested in implementing the feature ourselves.</li> <li>You are not sending unit and integration tests with it.</li> </ul>"},{"location":"about/faq/#do-you-support-y-method-of-deploying-headscale","title":"Do you support Y method of deploying headscale?","text":"<p>We currently support deploying headscale using our binaries and the DEB packages. Visit our installation guide using official releases for more information.</p> <p>In addition to that, you may use packages provided by the community or from distributions. Learn more in the installation guide using community packages.</p> <p>For convenience, we also build container images with headscale. But please be aware that we don't officially support deploying headscale using Docker. On our Discord server we have a \"docker-issues\" channel where you can ask for Docker-specific help to the community.</p>"},{"location":"about/faq/#scaling-how-many-clients-does-headscale-support","title":"Scaling / How many clients does Headscale support?","text":"<p>It depends. As often stated, Headscale is not enterprise software and our focus is homelabbers and self-hosters. Of course, we do not prevent people from using it in a commercial/professional setting and often get questions about scaling.</p> <p>Please note that when Headscale is developed, performance is not part of the consideration as the main audience is considered to be users with a modest amount of devices. We focus on correctness and feature parity with Tailscale SaaS over time.</p> <p>To understand if you might be able to use Headscale for your use case, I will describe two scenarios in an effort to explain what is the central bottleneck of Headscale:</p> <ol> <li> <p>An environment with 1000 servers</p> </li> <li> <p>they rarely \"move\" (change their endpoints)</p> </li> <li> <p>new nodes are added rarely</p> </li> <li> <p>An environment with 80 laptops/phones (end user devices)</p> </li> <li> <p>nodes move often, e.g. switching from home to office</p> </li> </ol> <p>Headscale calculates a map of all nodes that need to talk to each other, creating this \"world map\" requires a lot of CPU time. When an event that requires changes to this map happens, the whole \"world\" is recalculated, and a new \"world map\" is created for every node in the network.</p> <p>This means that under certain conditions, Headscale can likely handle 100s of devices (maybe more), if there is little to no change happening in the network. For example, in Scenario 1, the process of computing the world map is extremely demanding due to the size of the network, but when the map has been created and the nodes are not changing, the Headscale instance will likely return to a very low resource usage until the next time there is an event requiring the new map.</p> <p>In the case of Scenario 2, the process of computing the world map is less demanding due to the smaller size of the network, however, the type of nodes will likely change frequently, which would lead to a constant resource usage.</p> <p>Headscale will start to struggle when the two scenarios overlap, e.g. many nodes with frequent changes will cause the resource usage to remain constantly high. In the worst case scenario, the queue of nodes waiting for their map will grow to a point where Headscale never will be able to catch up, and nodes will never learn about the current state of the world.</p> <p>We expect that the performance will improve over time as we improve the code base, but it is not a focus. In general, we will never make the tradeoff to make things faster on the cost of less maintainable or readable code. We are a small team and have to optimise for maintainability.</p>"},{"location":"about/faq/#which-database-should-i-use","title":"Which database should I use?","text":"<p>We recommend the use of SQLite as database for headscale:</p> <ul> <li>SQLite is simple to setup and easy to use</li> <li>It scales well for all of headscale's use cases</li> <li>Development and testing happens primarily on SQLite</li> <li>PostgreSQL is still supported, but is considered to be in \"maintenance mode\"</li> </ul> <p>The headscale project itself does not provide a tool to migrate from PostgreSQL to SQLite. Please have a look at the related tools documentation for migration tooling provided by the community.</p> <p>The choice of database has little to no impact on the performance of the server, see Scaling / How many clients does Headscale support? for understanding how Headscale spends its resources.</p>"},{"location":"about/faq/#why-is-my-reverse-proxy-not-working-with-headscale","title":"Why is my reverse proxy not working with headscale?","text":"<p>We don't know. We don't use reverse proxies with headscale ourselves, so we don't have any experience with them. We have community documentation on how to configure various reverse proxies, and a dedicated \"reverse-proxy-issues\" channel on our Discord server where you can ask for help to the community.</p>"},{"location":"about/faq/#can-i-use-headscale-and-tailscale-on-the-same-machine","title":"Can I use headscale and tailscale on the same machine?","text":"<p>Running headscale on a machine that is also in the tailnet can cause problems with subnet routers, traffic relay nodes, and MagicDNS. It might work, but it is not supported.</p>"},{"location":"about/faq/#why-do-two-nodes-see-each-other-in-their-status-even-if-an-acl-allows-traffic-only-in-one-direction","title":"Why do two nodes see each other in their status, even if an ACL allows traffic only in one direction?","text":"<p>A frequent use case is to allow traffic only from one node to another, but not the other way around. For example, the workstation of an administrator should be able to connect to all nodes but the nodes themselves shouldn't be able to connect back to the administrator's node. Why do all nodes see the administrator's workstation in the output of <code>tailscale status</code>?</p> <p>This is essentially how Tailscale works. If traffic is allowed to flow in one direction, then both nodes see each other in their output of <code>tailscale status</code>. Traffic is still filtered according to the ACL, with the exception of <code>tailscale ping</code> which is always allowed in either direction.</p> <p>See also https://tailscale.com/kb/1087/device-visibility.</p>"},{"location":"about/features/","title":"Features","text":"<p>Headscale aims to implement a self-hosted, open source alternative to the Tailscale control server. Headscale's goal is to provide self-hosters and hobbyists with an open-source server they can use for their projects and labs. This page provides on overview of Headscale's feature and compatibility with the Tailscale control server:</p> <ul> <li> Full \"base\" support of Tailscale's features</li> <li> Node registration<ul> <li> Interactive</li> <li> Pre authenticated key</li> </ul> </li> <li> DNS<ul> <li> MagicDNS</li> <li> Global and restricted nameservers (split DNS)</li> <li> search domains</li> <li> Extra DNS records (Headscale only)</li> </ul> </li> <li> Taildrop (File Sharing)</li> <li> Routes<ul> <li> Subnet routers</li> <li> Exit nodes</li> </ul> </li> <li> Dual stack (IPv4 and IPv6)</li> <li> Ephemeral nodes</li> <li> Embedded DERP server</li> <li> Access control lists (GitHub label \"policy\")<ul> <li> ACL management via API</li> <li> Some Autogroups, currently: <code>autogroup:internet</code>,   <code>autogroup:nonroot</code>, <code>autogroup:member</code>, <code>autogroup:tagged</code></li> <li> Auto approvers for subnet   routers and exit   nodes</li> <li> Tailscale SSH</li> </ul> </li> <li> Node registration using Single-Sign-On (OpenID Connect) (GitHub label \"OIDC\")<ul> <li> Basic registration</li> <li> Update user profile from identity provider</li> <li> OIDC groups cannot be used in ACLs</li> </ul> </li> <li> Funnel (#1040)</li> <li> Serve (#1234)</li> <li> Network flow logs (#1687)</li> </ul>"},{"location":"about/help/","title":"Getting help","text":"<p>Join our Discord server for announcements and community support.</p> <p>Please report bugs via GitHub issues</p>"},{"location":"about/releases/","title":"Releases","text":"<p>All headscale releases are available on the GitHub release page. Those releases are available as binaries for various platforms and architectures, packages for Debian based systems and source code archives. Container images are available on Docker Hub and GitHub Container Registry.</p> <p>An Atom/RSS feed of headscale releases is available here.</p> <p>See the \"announcements\" channel on our Discord server for news about headscale.</p>"},{"location":"about/sponsor/","title":"Sponsor","text":"<p>If you like to support the development of headscale, please consider a donation via ko-fi.com/headscale. Thank you!</p>"},{"location":"ref/acls/","title":"ACLs","text":"<p>Headscale implements the same policy ACLs as Tailscale.com, adapted to the self-hosted environment.</p> <p>For instance, instead of referring to users when defining groups you must use users (which are the equivalent to user/logins in Tailscale.com).</p> <p>Please check https://tailscale.com/kb/1018/acls/ for further information.</p> <p>When using ACL's the User borders are no longer applied. All machines whichever the User have the ability to communicate with other hosts as long as the ACL's permits this exchange.</p>"},{"location":"ref/acls/#acls-use-case-example","title":"ACLs use case example","text":"<p>Let's build an example use case for a small business (It may be the place where ACL's are the most useful).</p> <p>We have a small company with a boss, an admin, two developers and an intern.</p> <p>The boss should have access to all servers but not to the user's hosts. Admin should also have access to all hosts except that their permissions should be limited to maintaining the hosts (for example purposes). The developers can do anything they want on dev hosts but only watch on productions hosts. Intern can only interact with the development servers.</p> <p>There's an additional server that acts as a router, connecting the VPN users to an internal network <code>10.20.0.0/16</code>. Developers must have access to those internal resources.</p> <p>Each user have at least a device connected to the network and we have some servers.</p> <ul> <li>database.prod</li> <li>database.dev</li> <li>app-server1.prod</li> <li>app-server1.dev</li> <li>billing.internal</li> <li>router.internal</li> </ul> <p></p>"},{"location":"ref/acls/#acl-setup","title":"ACL setup","text":"<p>ACLs have to be written in huJSON.</p> <p>When registering the servers we will need to add the flag <code>--advertise-tags=tag:&lt;tag1&gt;,tag:&lt;tag2&gt;</code>, and the user that is registering the server should be allowed to do it. Since anyone can add tags to a server they can register, the check of the tags is done on headscale server and only valid tags are applied. A tag is valid if the user that is registering it is allowed to do it.</p> <p>To use ACLs in headscale, you must edit your <code>config.yaml</code> file. In there you will find a <code>policy.path</code> parameter. This will need to point to your ACL file. More info on how these policies are written can be found here.</p> <p>Please reload or restart Headscale after updating the ACL file. Headscale may be reloaded either via its systemd service (<code>sudo systemctl reload headscale</code>) or by sending a SIGHUP signal (<code>sudo kill -HUP $(pidof headscale)</code>) to the main process. Headscale logs the result of ACL policy processing after each reload.</p> <p>Here are the ACL's to implement the same permissions as above:</p> acl.json<pre><code>{\n  // groups are collections of users having a common scope. A user can be in multiple groups\n  // groups cannot be composed of groups\n  \"groups\": {\n    \"group:boss\": [\"boss@\"],\n    \"group:dev\": [\"dev1@\", \"dev2@\"],\n    \"group:admin\": [\"admin1@\"],\n    \"group:intern\": [\"intern1@\"]\n  },\n  // tagOwners in tailscale is an association between a TAG and the people allowed to set this TAG on a server.\n  // This is documented [here](https://tailscale.com/kb/1068/acl-tags#defining-a-tag)\n  // and explained [here](https://tailscale.com/blog/rbac-like-it-was-meant-to-be/)\n  \"tagOwners\": {\n    // the administrators can add servers in production\n    \"tag:prod-databases\": [\"group:admin\"],\n    \"tag:prod-app-servers\": [\"group:admin\"],\n\n    // the boss can tag any server as internal\n    \"tag:internal\": [\"group:boss\"],\n\n    // dev can add servers for dev purposes as well as admins\n    \"tag:dev-databases\": [\"group:admin\", \"group:dev\"],\n    \"tag:dev-app-servers\": [\"group:admin\", \"group:dev\"]\n\n    // interns cannot add servers\n  },\n  // hosts should be defined using its IP addresses and a subnet mask.\n  // to define a single host, use a /32 mask. You cannot use DNS entries here,\n  // as they're prone to be hijacked by replacing their IP addresses.\n  // see https://github.com/tailscale/tailscale/issues/3800 for more information.\n  \"hosts\": {\n    \"postgresql.internal\": \"10.20.0.2/32\",\n    \"webservers.internal\": \"10.20.10.1/29\"\n  },\n  \"acls\": [\n    // boss have access to all servers\n    {\n      \"action\": \"accept\",\n      \"src\": [\"group:boss\"],\n      \"dst\": [\n        \"tag:prod-databases:*\",\n        \"tag:prod-app-servers:*\",\n        \"tag:internal:*\",\n        \"tag:dev-databases:*\",\n        \"tag:dev-app-servers:*\"\n      ]\n    },\n\n    // admin have only access to administrative ports of the servers, in tcp/22\n    {\n      \"action\": \"accept\",\n      \"src\": [\"group:admin\"],\n      \"proto\": \"tcp\",\n      \"dst\": [\n        \"tag:prod-databases:22\",\n        \"tag:prod-app-servers:22\",\n        \"tag:internal:22\",\n        \"tag:dev-databases:22\",\n        \"tag:dev-app-servers:22\"\n      ]\n    },\n\n    // we also allow admin to ping the servers\n    {\n      \"action\": \"accept\",\n      \"src\": [\"group:admin\"],\n      \"proto\": \"icmp\",\n      \"dst\": [\n        \"tag:prod-databases:*\",\n        \"tag:prod-app-servers:*\",\n        \"tag:internal:*\",\n        \"tag:dev-databases:*\",\n        \"tag:dev-app-servers:*\"\n      ]\n    },\n\n    // developers have access to databases servers and application servers on all ports\n    // they can only view the applications servers in prod and have no access to databases servers in production\n    {\n      \"action\": \"accept\",\n      \"src\": [\"group:dev\"],\n      \"dst\": [\n        \"tag:dev-databases:*\",\n        \"tag:dev-app-servers:*\",\n        \"tag:prod-app-servers:80,443\"\n      ]\n    },\n    // developers have access to the internal network through the router.\n    // the internal network is composed of HTTPS endpoints and Postgresql\n    // database servers.\n    {\n      \"action\": \"accept\",\n      \"src\": [\"group:dev\"],\n      \"dst\": [\"10.20.0.0/16:443,5432\"]\n    },\n\n    // servers should be able to talk to database in tcp/5432. Database should not be able to initiate connections to\n    // applications servers\n    {\n      \"action\": \"accept\",\n      \"src\": [\"tag:dev-app-servers\"],\n      \"proto\": \"tcp\",\n      \"dst\": [\"tag:dev-databases:5432\"]\n    },\n    {\n      \"action\": \"accept\",\n      \"src\": [\"tag:prod-app-servers\"],\n      \"dst\": [\"tag:prod-databases:5432\"]\n    },\n\n    // interns have access to dev-app-servers only in reading mode\n    {\n      \"action\": \"accept\",\n      \"src\": [\"group:intern\"],\n      \"dst\": [\"tag:dev-app-servers:80,443\"]\n    },\n\n    // We still have to allow internal users communications since nothing guarantees that each user have\n    // their own users.\n    { \"action\": \"accept\", \"src\": [\"boss@\"], \"dst\": [\"boss@:*\"] },\n    { \"action\": \"accept\", \"src\": [\"dev1@\"], \"dst\": [\"dev1@:*\"] },\n    { \"action\": \"accept\", \"src\": [\"dev2@\"], \"dst\": [\"dev2@:*\"] },\n    { \"action\": \"accept\", \"src\": [\"admin1@\"], \"dst\": [\"admin1@:*\"] },\n    { \"action\": \"accept\", \"src\": [\"intern1@\"], \"dst\": [\"intern1@:*\"] }\n  ]\n}\n</code></pre>"},{"location":"ref/configuration/","title":"Configuration","text":"<ul> <li>Headscale loads its configuration from a YAML file</li> <li>It searches for <code>config.yaml</code> in the following paths:<ul> <li><code>/etc/headscale</code></li> <li><code>$HOME/.headscale</code></li> <li>the current working directory</li> </ul> </li> <li>To load the configuration from a different path, use:<ul> <li>the command line flag <code>-c</code>, <code>--config</code></li> <li>the environment variable <code>HEADSCALE_CONFIG</code></li> </ul> </li> <li>Validate the configuration file with: <code>headscale configtest</code></li> </ul> <p>Get the example configuration from the GitHub repository</p> <p>Always select the same GitHub tag as the released version you use to ensure you have the correct example configuration. The <code>main</code> branch might contain unreleased changes.</p> View on GitHubDownload with <code>wget</code>Download with <code>curl</code> <ul> <li>Development version: https://github.com/juanfont/headscale/blob/main/config-example.yaml</li> <li>Version 0.26.1: https://github.com/juanfont/headscale/blob/v0.26.1/config-example.yaml</li> </ul> <pre><code># Development version\nwget -O config.yaml https://raw.githubusercontent.com/juanfont/headscale/main/config-example.yaml\n\n# Version 0.26.1\nwget -O config.yaml https://raw.githubusercontent.com/juanfont/headscale/v0.26.1/config-example.yaml\n</code></pre> <pre><code># Development version\ncurl -o config.yaml https://raw.githubusercontent.com/juanfont/headscale/main/config-example.yaml\n\n# Version 0.26.1\ncurl -o config.yaml https://raw.githubusercontent.com/juanfont/headscale/v0.26.1/config-example.yaml\n</code></pre>"},{"location":"ref/debug/","title":"Debugging and troubleshooting","text":"<p>Headscale and Tailscale provide debug and introspection capabilities that can be helpful when things don't work as expected. This page explains some debugging techniques to help pinpoint problems.</p> <p>Please also have a look at Tailscale's Troubleshooting guide. It offers a many tips and suggestions to troubleshoot common issues.</p>"},{"location":"ref/debug/#tailscale","title":"Tailscale","text":"<p>The Tailscale client itself offers many commands to introspect its state as well as the state of the network:</p> <ul> <li>Check local network conditions: <code>tailscale netcheck</code></li> <li>Get the client status: <code>tailscale status --json</code></li> <li>Get DNS status: <code>tailscale dns status --all</code></li> <li>Client logs: <code>tailscale debug daemon-logs</code></li> <li>Client netmap: <code>tailscale debug netmap</code></li> <li>Test DERP connection: <code>tailscale debug derp headscale</code></li> <li>And many more, see: <code>tailscale debug --help</code></li> </ul> <p>Many of the commands are helpful when trying to understand differences between Headscale and Tailscale SaaS.</p>"},{"location":"ref/debug/#headscale","title":"Headscale","text":""},{"location":"ref/debug/#application-logging","title":"Application logging","text":"<p>The log levels <code>debug</code> and <code>trace</code> can be useful to get more information from Headscale.</p> <pre><code>log:\n  # Valid log levels: panic, fatal, error, warn, info, debug, trace\n  level: debug\n</code></pre>"},{"location":"ref/debug/#database-logging","title":"Database logging","text":"<p>The database debug mode logs all database queries. Enable it to see how Headscale interacts with its database. This also requires the application log level to be set to either <code>debug</code> or <code>trace</code>.</p> <pre><code>database:\n  # Enable debug mode. This setting requires the log.level to be set to \"debug\" or \"trace\".\n  debug: false\n\nlog:\n  # Valid log levels: panic, fatal, error, warn, info, debug, trace\n  level: debug\n</code></pre>"},{"location":"ref/debug/#metrics-and-debug-endpoint","title":"Metrics and debug endpoint","text":"<p>Headscale provides a metrics and debug endpoint. It allows to introspect different aspects such as:</p> <ul> <li>Information about the Go runtime, memory usage and statistics</li> <li>Connected nodes and pending registrations</li> <li>Active ACLs, filters and SSH policy</li> <li>Current DERPMap</li> <li>Prometheus metrics</li> </ul> <p>Keep the metrics and debug endpoint private</p> <p>The listen address and port can be configured with the <code>metrics_listen_addr</code> variable in the configuration file. By default it listens on localhost, port 9090.</p> <p>Keep the metrics and debug endpoint private to your internal network and don't expose it to the Internet.</p> <p>Query metrics via http://localhost:9090/metrics and get an overview of available debug information via http://localhost:9090/debug/. Metrics may be queried from outside localhost but the debug interface is subject to additional protection despite listening on all interfaces.</p> Direct accessSSH port forwardingVia debug keyVia debug IP address <p>Access the debug interface directly on the server where Headscale is installed.</p> <pre><code>curl http://localhost:9090/debug/\n</code></pre> <p>Use SSH port forwarding to forward Headscale's metrics and debug port to your device.</p> <pre><code>ssh &lt;HEADSCALE_SERVER&gt; -L 9090:localhost:9090\n</code></pre> <p>Access the debug interface on your device by opening http://localhost:9090/debug/ in your web browser.</p> <p>The access control of the debug interface supports the use of a debug key. Traffic is accepted if the path to a debug key is set via the environment variable <code>TS_DEBUG_KEY_PATH</code> and the debug key sent as value for <code>debugkey</code> parameter with each request.</p> <pre><code>openssl rand -hex 32 | tee debugkey.txt\nexport TS_DEBUG_KEY_PATH=debugkey.txt\nheadscale serve\n</code></pre> <p>Access the debug interface on your device by opening <code>http://&lt;IP_OF_HEADSCALE&gt;:9090/debug/?debugkey=&lt;DEBUG_KEY&gt;</code> in your web browser. The <code>debugkey</code> parameter must be sent with every request.</p> <p>The debug endpoint expects traffic from localhost. A different debug IP address may be configured by setting the <code>TS_ALLOW_DEBUG_IP</code> environment variable before starting Headscale. The debug IP address is ignored when the HTTP header <code>X-Forwarded-For</code> is present.</p> <pre><code>export TS_ALLOW_DEBUG_IP=192.168.0.10       # IP address of your device\nheadscale serve\n</code></pre> <p>Access the debug interface on your device by opening <code>http://&lt;IP_OF_HEADSCALE&gt;:9090/debug/</code> in your web browser.</p>"},{"location":"ref/dns/","title":"DNS","text":"<p>Headscale supports most DNS features from Tailscale. DNS related settings can be configured within <code>dns</code> section of the configuration file.</p>"},{"location":"ref/dns/#setting-extra-dns-records","title":"Setting extra DNS records","text":"<p>Headscale allows to set extra DNS records which are made available via MagicDNS. Extra DNS records can be configured either via static entries in the configuration file or from a JSON file that Headscale continuously watches for changes:</p> <ul> <li>Use the <code>dns.extra_records</code> option in the configuration file for entries that are static and   don't change while Headscale is running. Those entries are processed when Headscale is starting up and changes to the   configuration require a restart of Headscale.</li> <li>For dynamic DNS records that may be added, updated or removed while Headscale is running or DNS records that are   generated by scripts the option <code>dns.extra_records_path</code> in the configuration file is useful.   Set it to the absolute path of the JSON file containing DNS records and Headscale processes this file as it detects   changes.</li> </ul> <p>An example use case is to serve multiple apps on the same host via a reverse proxy like NGINX, in this case a Prometheus monitoring stack. This allows to nicely access the service with \"http://grafana.myvpn.example.com\" instead of the hostname and port combination \"http://hostname-in-magic-dns.myvpn.example.com:3000\".</p> <p>Limitations</p> <p>Currently, only A and AAAA records are processed by Tailscale.</p> <ol> <li> <p>Configure extra DNS records using one of the available configuration options:</p> Static entries, via <code>dns.extra_records</code>Dynamic entries, via <code>dns.extra_records_path</code> config.yaml<pre><code>dns:\n  ...\n  extra_records:\n    - name: \"grafana.myvpn.example.com\"\n      type: \"A\"\n      value: \"100.64.0.3\"\n\n    - name: \"prometheus.myvpn.example.com\"\n      type: \"A\"\n      value: \"100.64.0.3\"\n  ...\n</code></pre> <p>Restart your headscale instance.</p> extra-records.json<pre><code>[\n  {\n    \"name\": \"grafana.myvpn.example.com\",\n    \"type\": \"A\",\n    \"value\": \"100.64.0.3\"\n  },\n  {\n    \"name\": \"prometheus.myvpn.example.com\",\n    \"type\": \"A\",\n    \"value\": \"100.64.0.3\"\n  }\n]\n</code></pre> <p>Headscale picks up changes to the above JSON file automatically.</p> <p>Good to know</p> <ul> <li>The <code>dns.extra_records_path</code> option in the configuration file needs to reference the   JSON file containing extra DNS records.</li> <li>Be sure to \"sort keys\" and produce a stable output in case you generate the JSON file with a script.   Headscale uses a checksum to detect changes to the file and a stable output avoids unnecessary processing.</li> </ul> </li> <li> <p>Verify that DNS records are properly set using the DNS querying tool of your choice:</p> Query with digQuery with drill <pre><code>dig +short grafana.myvpn.example.com\n100.64.0.3\n</code></pre> <pre><code>drill -Q grafana.myvpn.example.com\n100.64.0.3\n</code></pre> </li> <li> <p>Optional: Setup the reverse proxy</p> <p>The motivating example here was to be able to access internal monitoring services on the same host without specifying a port, depicted as NGINX configuration snippet:</p> nginx.conf<pre><code>server {\n    listen 80;\n    listen [::]:80;\n\n    server_name grafana.myvpn.example.com;\n\n    location / {\n        proxy_pass http://localhost:3000;\n        proxy_set_header Host $http_host;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n    }\n\n}\n</code></pre> </li> </ol>"},{"location":"ref/oidc/","title":"OpenID Connect","text":"<p>Headscale supports authentication via external identity providers using OpenID Connect (OIDC). It features:</p> <ul> <li>Auto configuration via OpenID Connect Discovery Protocol</li> <li>Proof Key for Code Exchange (PKCE) code verification</li> <li>Authorization based on a user's domain, email address or group membership</li> <li>Synchronization of standard OIDC claims</li> </ul> <p>Please see limitations for known issues and limitations.</p>"},{"location":"ref/oidc/#configuration","title":"Configuration","text":"<p>OpenID requires configuration in Headscale and your identity provider:</p> <ul> <li>Headscale: The <code>oidc</code> section of the Headscale configuration contains all available configuration   options along with a description and their default values.</li> <li>Identity provider: Please refer to the official documentation of your identity provider for specific instructions.   Additionally, there might be some useful hints in the Identity provider specific   configuration section below.</li> </ul>"},{"location":"ref/oidc/#basic-configuration","title":"Basic configuration","text":"<p>A basic configuration connects Headscale to an identity provider and typically requires:</p> <ul> <li>OpenID Connect Issuer URL from the identity provider. Headscale uses the OpenID Connect Discovery Protocol 1.0 to   automatically obtain OpenID configuration parameters (example: <code>https://sso.example.com</code>).</li> <li>Client ID from the identity provider (example: <code>headscale</code>).</li> <li>Client secret generated by the identity provider (example: <code>generated-secret</code>).</li> <li>Redirect URI for your identity provider (example: <code>https://headscale.example.com/oidc/callback</code>).</li> </ul> HeadscaleIdentity provider <pre><code>oidc:\n  issuer: \"https://sso.example.com\"\n  client_id: \"headscale\"\n  client_secret: \"generated-secret\"\n</code></pre> <ul> <li>Create a new confidential client (<code>Client ID</code>, <code>Client secret</code>)</li> <li>Add Headscale's OIDC callback URL as valid redirect URL: <code>https://headscale.example.com/oidc/callback</code></li> <li>Configure additional parameters to improve user experience such as: name, description, logo, \u2026</li> </ul>"},{"location":"ref/oidc/#enable-pkce-recommended","title":"Enable PKCE (recommended)","text":"<p>Proof Key for Code Exchange (PKCE) adds an additional layer of security to the OAuth 2.0 authorization code flow by preventing authorization code interception attacks, see: https://datatracker.ietf.org/doc/html/rfc7636. PKCE is recommended and needs to be configured for Headscale and the identity provider alike:</p> HeadscaleIdentity provider <pre><code>oidc:\n  issuer: \"https://sso.example.com\"\n  client_id: \"headscale\"\n  client_secret: \"generated-secret\"\n  pkce:\n    enabled: true\n</code></pre> <ul> <li>Enable PKCE for the headscale client</li> <li>Set the PKCE challenge method to \"S256\"</li> </ul>"},{"location":"ref/oidc/#authorize-users-with-filters","title":"Authorize users with filters","text":"<p>Headscale allows to filter for allowed users based on their domain, email address or group membership. These filters can be helpful to apply additional restrictions and control which users are allowed to join. Filters are disabled by default, users are allowed to join once the authentication with the identity provider succeeds. In case multiple filters are configured, a user needs to pass all of them.</p> Allowed domainsAllowed users/emailsAllowed groups <ul> <li>Check the email domain of each authenticating user against the list of allowed domains and only authorize users   whose email domain matches <code>example.com</code>.</li> <li>Access allowed: <code>alice@example.com</code></li> <li>Access denied: <code>bob@example.net</code></li> </ul> <pre><code>oidc:\n  issuer: \"https://sso.example.com\"\n  client_id: \"headscale\"\n  client_secret: \"generated-secret\"\n  allowed_domains:\n    - \"example.com\"\n</code></pre> <ul> <li>Check the email address of each authenticating user against the list of allowed email addresses and only authorize   users whose email is part of the <code>allowed_users</code> list.</li> <li>Access allowed: <code>alice@example.com</code>, <code>bob@example.net</code></li> <li>Access denied: <code>mallory@example.net</code></li> </ul> <pre><code>oidc:\n  issuer: \"https://sso.example.com\"\n  client_id: \"headscale\"\n  client_secret: \"generated-secret\"\n  allowed_users:\n    - \"alice@example.com\"\n    - \"bob@example.net\"\n</code></pre> <ul> <li>Use the OIDC <code>groups</code> claim of each authenticating user to get their group membership and only authorize users   which are members in at least one of the referenced groups.</li> <li>Access allowed: users in the <code>headscale_users</code> group</li> <li>Access denied: users without groups, users with other groups</li> </ul> <pre><code>oidc:\n  issuer: \"https://sso.example.com\"\n  client_id: \"headscale\"\n  client_secret: \"generated-secret\"\n  scope: [\"openid\", \"profile\", \"email\", \"groups\"]\n  allowed_groups:\n    - \"headscale_users\"\n</code></pre>"},{"location":"ref/oidc/#customize-node-expiration","title":"Customize node expiration","text":"<p>The node expiration is the amount of time a node is authenticated with OpenID Connect until it expires and needs to reauthenticate. The default node expiration is 180 days. This can either be customized or set to the expiration from the Access Token.</p> Customize node expirationUse expiration from Access Token <pre><code>oidc:\n  issuer: \"https://sso.example.com\"\n  client_id: \"headscale\"\n  client_secret: \"generated-secret\"\n  expiry: 30d   # Use 0 to disable node expiration\n</code></pre> <p>Please keep in mind that the Access Token is typically a short-lived token that expires within a few minutes. You will have to configure token expiration in your identity provider to avoid frequent re-authentication.</p> <pre><code>oidc:\n  issuer: \"https://sso.example.com\"\n  client_id: \"headscale\"\n  client_secret: \"generated-secret\"\n  use_expiry_from_token: true\n</code></pre> <p>Expire a node and force re-authentication</p> <p>A node can be expired immediately via: <pre><code>headscale node expire -i &lt;NODE_ID&gt;\n</code></pre></p>"},{"location":"ref/oidc/#reference-a-user-in-the-policy","title":"Reference a user in the policy","text":"<p>You may refer to users in the Headscale policy via:</p> <ul> <li>Email address</li> <li>Username</li> <li>Provider identifier (only available in the database or from your identity provider)</li> </ul> <p>A user identifier in the policy must contain a single <code>@</code></p> <p>The Headscale policy requires a single <code>@</code> to reference a user. If the username or provider identifier doesn't already contain a single <code>@</code>, it needs to be appended at the end. For example: the username <code>ssmith</code> has to be written as <code>ssmith@</code> to be correctly identified as user within the policy.</p> <p>Email address or username might be updated by users</p> <p>Many identity providers allow users to update their own profile. Depending on the identity provider and its configuration, the values for username or email address might change over time. This might have unexpected consequences for Headscale where a policy might no longer work or a user might obtain more access by hijacking an existing username or email address.</p>"},{"location":"ref/oidc/#supported-oidc-claims","title":"Supported OIDC claims","text":"<p>Headscale uses the standard OIDC claims to populate and update its local user profile on each login. OIDC claims are read from the ID Token or from the UserInfo endpoint.</p> Headscale profile OIDC claim Notes / examples email address <code>email</code> Only used when <code>email_verified: true</code> display name <code>name</code> eg: <code>Sam Smith</code> username <code>preferred_username</code> Depends on identity provider, eg: <code>ssmith</code>, <code>ssmith@idp.example.com</code>, <code>\\\\example.com\\ssmith</code> profile picture <code>picture</code> URL to a profile picture or avatar provider identifier <code>iss</code>, <code>sub</code> A stable and unique identifier for a user, typically a combination of <code>iss</code> and <code>sub</code> OIDC claims <code>groups</code> Only used to filter for allowed groups"},{"location":"ref/oidc/#limitations","title":"Limitations","text":"<ul> <li>Support for OpenID Connect aims to be generic and vendor independent. It offers only limited support for quirks of   specific identity providers.</li> <li>OIDC groups cannot be used in ACLs.</li> <li>The username provided by the identity provider needs to adhere to this pattern:<ul> <li>The username must be at least two characters long.</li> <li>It must only contain letters, digits, hyphens, dots, underscores, and up to a single <code>@</code>.</li> <li>The username must start with a letter.</li> </ul> </li> <li>A user's email address is only synchronized to the local user profile when the identity provider marks the email   address as verified (<code>email_verified: true</code>).</li> </ul> <p>Please see the GitHub label \"OIDC\" for OIDC related issues.</p>"},{"location":"ref/oidc/#identity-provider-specific-configuration","title":"Identity provider specific configuration","text":"<p>Third-party software and services</p> <p>This section of the documentation is specific for third-party software and services. We recommend users read the third-party documentation on how to configure and integrate an OIDC client. Please see the Configuration section for a description of Headscale's OIDC related configuration settings.</p> <p>Any identity provider with OpenID Connect support should \"just work\" with Headscale. The following identity providers are known to work:</p> <ul> <li>Authelia</li> <li>Authentik</li> <li>Kanidm</li> <li>Keycloak</li> </ul>"},{"location":"ref/oidc/#authelia","title":"Authelia","text":"<p>Authelia is fully supported by Headscale.</p>"},{"location":"ref/oidc/#additional-configuration-to-authorize-users-based-on-filters","title":"Additional configuration to authorize users based on filters","text":"<p>Authelia (4.39.0 or newer) no longer provides standard OIDC claims such as <code>email</code> or <code>groups</code> via the ID Token. The OIDC <code>email</code> and <code>groups</code> claims are used to authorize users with filters. This extra configuration step is only needed if you need to authorize access based on one of the following user properties:</p> <ul> <li>domain</li> <li>email address</li> <li>group membership</li> </ul> <p>Please follow the instructions from Authelia's documentation on how to Restore Functionality Prior to Claims Parameter.</p>"},{"location":"ref/oidc/#authentik","title":"Authentik","text":"<ul> <li>Authentik is fully supported by Headscale.</li> <li>Headscale does not JSON Web Encryption. Leave the field   <code>Encryption Key</code> in the providers section unset.</li> </ul>"},{"location":"ref/oidc/#google-oauth","title":"Google OAuth","text":"<p>No username due to missing preferred_username</p> <p>Google OAuth does not send the <code>preferred_username</code> claim when the scope <code>profile</code> is requested. The username in Headscale will be blank/not set.</p> <p>In order to integrate Headscale with Google, you'll need to have a Google Cloud Console account.</p> <p>Google OAuth has a verification process if you need to have users authenticate who are outside of your domain. If you only need to authenticate users from your domain name (ie <code>@example.com</code>), you don't need to go through the verification process.</p> <p>However if you don't have a domain, or need to add users outside of your domain, you can manually add emails via Google Console.</p>"},{"location":"ref/oidc/#steps","title":"Steps","text":"<ol> <li>Go to Google Console and login or create an account if you don't have one.</li> <li>Create a project (if you don't already have one).</li> <li>On the left hand menu, go to <code>APIs and services</code> -&gt; <code>Credentials</code></li> <li>Click <code>Create Credentials</code> -&gt; <code>OAuth client ID</code></li> <li>Under <code>Application Type</code>, choose <code>Web Application</code></li> <li>For <code>Name</code>, enter whatever you like</li> <li>Under <code>Authorised redirect URIs</code>, add Headscale's OIDC callback URL: <code>https://headscale.example.com/oidc/callback</code></li> <li>Click <code>Save</code> at the bottom of the form</li> <li>Take note of the <code>Client ID</code> and <code>Client secret</code>, you can also download it for reference if you need it.</li> <li>Configure Headscale following the \"Basic configuration\" steps. The issuer URL for Google     OAuth is: <code>https://accounts.google.com</code>.</li> </ol>"},{"location":"ref/oidc/#kanidm","title":"Kanidm","text":"<ul> <li>Kanidm is fully supported by Headscale.</li> <li>Groups for the allowed groups filter need to be specified with their full SPN, for   example: <code>headscale_users@sso.example.com</code>.</li> </ul>"},{"location":"ref/oidc/#keycloak","title":"Keycloak","text":"<p>Keycloak is fully supported by Headscale.</p>"},{"location":"ref/oidc/#additional-configuration-to-use-the-allowed-groups-filter","title":"Additional configuration to use the allowed groups filter","text":"<p>Keycloak has no built-in client scope for the OIDC <code>groups</code> claim. This extra configuration step is only needed if you need to authorize access based on group membership.</p> <ul> <li>Create a new client scope <code>groups</code> for OpenID Connect:<ul> <li>Configure a <code>Group Membership</code> mapper with name <code>groups</code> and the token claim name <code>groups</code>.</li> <li>Enable the mapper for the ID Token, Access Token and UserInfo endpoint.</li> </ul> </li> <li>Configure the new client scope for your Headscale client:<ul> <li>Edit the Headscale client.</li> <li>Search for the client scope <code>group</code>.</li> <li>Add it with assigned type <code>Default</code>.</li> </ul> </li> <li>Configure the allowed groups in Headscale. Keep in mind that groups in Keycloak start   with a leading <code>/</code>.</li> </ul>"},{"location":"ref/oidc/#microsoft-entra-id","title":"Microsoft Entra ID","text":"<p>In order to integrate Headscale with Microsoft Entra ID, you'll need to provision an App Registration with the correct scopes and redirect URI.</p> <p>Configure Headscale following the \"Basic configuration\" steps. The issuer URL for Microsoft Entra ID is: <code>https://login.microsoftonline.com/&lt;tenant-UUID&gt;/v2.0</code>. The following <code>extra_params</code> might be useful:</p> <ul> <li><code>domain_hint: example.com</code> to use your own domain</li> <li><code>prompt: select_account</code> to force an account picker during login</li> </ul>"},{"location":"ref/remote-cli/","title":"Controlling headscale with remote CLI","text":"<p>This documentation has the goal of showing a user how-to control a headscale instance from a remote machine with the <code>headscale</code> command line binary.</p>"},{"location":"ref/remote-cli/#prerequisite","title":"Prerequisite","text":"<ul> <li>A workstation to run <code>headscale</code> (any supported platform, e.g. Linux).</li> <li>A headscale server with gRPC enabled.</li> <li>Connections to the gRPC port (default: <code>50443</code>) are allowed.</li> <li>Remote access requires an encrypted connection via TLS.</li> <li>An API key to authenticate with the headscale server.</li> </ul>"},{"location":"ref/remote-cli/#create-an-api-key","title":"Create an API key","text":"<p>We need to create an API key to authenticate with the remote headscale server when using it from our workstation.</p> <p>To create an API key, log into your headscale server and generate a key:</p> <pre><code>headscale apikeys create --expiration 90d\n</code></pre> <p>Copy the output of the command and save it for later. Please note that you can not retrieve a key again, if the key is lost, expire the old one, and create a new key.</p> <p>To list the keys currently associated with the server:</p> <pre><code>headscale apikeys list\n</code></pre> <p>and to expire a key:</p> <pre><code>headscale apikeys expire --prefix \"&lt;PREFIX&gt;\"\n</code></pre>"},{"location":"ref/remote-cli/#download-and-configure-headscale","title":"Download and configure headscale","text":"<ol> <li> <p>Download the <code>headscale</code> binary from GitHub's release page. Make     sure to use the same version as on the server.</p> </li> <li> <p>Put the binary somewhere in your <code>PATH</code>, e.g. <code>/usr/local/bin/headscale</code></p> </li> <li> <p>Make <code>headscale</code> executable:</p> <pre><code>chmod +x /usr/local/bin/headscale\n</code></pre> </li> <li> <p>Provide the connection parameters for the remote headscale server either via a minimal YAML configuration file or via     environment variables:</p> Minimal YAML configuration fileEnvironment variables config.yaml<pre><code>cli:\n    address: &lt;HEADSCALE_ADDRESS&gt;:&lt;PORT&gt;\n    api_key: &lt;API_KEY_FROM_PREVIOUS_STEP&gt;\n</code></pre> <pre><code>export HEADSCALE_CLI_ADDRESS=\"&lt;HEADSCALE_ADDRESS&gt;:&lt;PORT&gt;\"\nexport HEADSCALE_CLI_API_KEY=\"&lt;API_KEY_FROM_PREVIOUS_STEP&gt;\"\n</code></pre> <p>Bug</p> <p>Headscale currently requires at least an empty configuration file when environment variables are used to specify connection details. See issue 2193 for more information.</p> <p>This instructs the <code>headscale</code> binary to connect to a remote instance at <code>&lt;HEADSCALE_ADDRESS&gt;:&lt;PORT&gt;</code>, instead of connecting to the local instance.</p> </li> <li> <p>Test the connection</p> <p>Let us run the headscale command to verify that we can connect by listing our nodes:</p> <pre><code>headscale nodes list\n</code></pre> <p>You should now be able to see a list of your nodes from your workstation, and you can now control the headscale server from your workstation.</p> </li> </ol>"},{"location":"ref/remote-cli/#behind-a-proxy","title":"Behind a proxy","text":"<p>It is possible to run the gRPC remote endpoint behind a reverse proxy, like Nginx, and have it run on the same port as headscale.</p> <p>While this is not a supported feature, an example on how this can be set up on NixOS is shown here.</p>"},{"location":"ref/remote-cli/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Make sure you have the same headscale version on your server and workstation.</li> <li>Ensure that connections to the gRPC port are allowed.</li> <li>Verify that your TLS certificate is valid and trusted.</li> <li>If you don't have access to a trusted certificate (e.g. from Let's Encrypt), either:<ul> <li>Add your self-signed certificate to the trust store of your OS or</li> <li>Disable certificate verification by either setting <code>cli.insecure: true</code> in the configuration file or by setting   <code>HEADSCALE_CLI_INSECURE=1</code> via an environment variable. We do not recommend to disable certificate validation.</li> </ul> </li> </ul>"},{"location":"ref/routes/","title":"Routes","text":"<p>Headscale supports route advertising and can be used to manage subnet routers and exit nodes for a tailnet.</p> <ul> <li>Subnet routers may be used to connect an existing network such as a virtual   private cloud or an on-premise network with your tailnet. Use a subnet router to access devices where Tailscale can't   be installed or to gradually rollout Tailscale.</li> <li>Exit nodes can be used to route all Internet traffic for another Tailscale   node. Use it to securely access the Internet on an untrusted Wi-Fi or to access online services that expect traffic   from a specific IP address.</li> </ul>"},{"location":"ref/routes/#subnet-router","title":"Subnet router","text":"<p>The setup of a subnet router requires double opt-in, once from a subnet router and once on the control server to allow its use within the tailnet. Optionally, use <code>autoApprovers</code> to automatically approve routes from a subnet router.</p>"},{"location":"ref/routes/#setup-a-subnet-router","title":"Setup a subnet router","text":""},{"location":"ref/routes/#configure-a-node-as-subnet-router","title":"Configure a node as subnet router","text":"<p>Register a node and advertise the routes it should handle as comma separated list:</p> <pre><code>$ sudo tailscale up --login-server &lt;YOUR_HEADSCALE_URL&gt; --advertise-routes=10.0.0.0/8,192.168.0.0/24\n</code></pre> <p>If the node is already registered, it can advertise new routes or update previously announced routes with:</p> <pre><code>$ sudo tailscale set --advertise-routes=10.0.0.0/8,192.168.0.0/24\n</code></pre> <p>Finally, enable IP forwarding to route traffic.</p>"},{"location":"ref/routes/#enable-the-subnet-router-on-the-control-server","title":"Enable the subnet router on the control server","text":"<p>The routes of a tailnet can be displayed with the <code>headscale nodes list-routes</code> command. A subnet router with the hostname <code>myrouter</code> announced the IPv4 networks <code>10.0.0.0/8</code> and <code>192.168.0.0/24</code>. Those need to be approved before they can be used.</p> <pre><code>$ headscale nodes list-routes\nID | Hostname | Approved | Available                  | Serving (Primary)\n1  | myrouter |          | 10.0.0.0/8, 192.168.0.0/24 |\n</code></pre> <p>Approve all desired routes of a subnet router by specifying them as comma separated list:</p> <pre><code>$ headscale nodes approve-routes --identifier 1 --routes 10.0.0.0/8,192.168.0.0/24\nNode updated\n</code></pre> <p>The node <code>myrouter</code> can now route the IPv4 networks <code>10.0.0.0/8</code> and <code>192.168.0.0/24</code> for the tailnet.</p> <pre><code>$ headscale nodes list-routes\nID | Hostname | Approved                   | Available                  | Serving (Primary)\n1  | myrouter | 10.0.0.0/8, 192.168.0.0/24 | 10.0.0.0/8, 192.168.0.0/24 | 10.0.0.0/8, 192.168.0.0/24\n</code></pre>"},{"location":"ref/routes/#use-the-subnet-router","title":"Use the subnet router","text":"<p>To accept routes advertised by a subnet router on a node:</p> <pre><code>$ sudo tailscale set --accept-routes\n</code></pre> <p>Please refer to the official Tailscale documentation for how to use a subnet router on different operating systems.</p>"},{"location":"ref/routes/#restrict-the-use-of-a-subnet-router-with-acl","title":"Restrict the use of a subnet router with ACL","text":"<p>The routes announced by subnet routers are available to the nodes in a tailnet. By default, without an ACL enabled, all nodes can accept and use such routes. Configure an ACL to explicitly manage who can use routes.</p> <p>The ACL snippet below defines three hosts, a subnet router <code>router</code>, a regular node <code>node</code> and <code>service.example.net</code> as internal service that can be reached via a route on the subnet router <code>router</code>. It allows the node <code>node</code> to access <code>service.example.net</code> on port 80 and 443 which is reachable via the subnet router. Access to the subnet router itself is denied.</p> Access the routes of a subnet router without the subnet router itself<pre><code>{\n  \"hosts\": {\n    // the router is not referenced but announces 192.168.0.0/24\"\n    \"router\": \"100.64.0.1/32\",\n    \"node\": \"100.64.0.2/32\",\n    \"service.example.net\": \"192.168.0.1/32\"\n  },\n  \"acls\": [\n    {\n      \"action\": \"accept\",\n      \"src\": [\"node\"],\n      \"dst\": [\"service.example.net:80,443\"]\n    }\n  ]\n}\n</code></pre>"},{"location":"ref/routes/#automatically-approve-routes-of-a-subnet-router","title":"Automatically approve routes of a subnet router","text":"<p>The initial setup of a subnet router usually requires manual approval of their announced routes on the control server before they can be used by a node in a tailnet. Headscale supports the <code>autoApprovers</code> section of an ACL to automate the approval of routes served with a subnet router.</p> <p>The ACL snippet below defines the tag <code>tag:router</code> owned by the user <code>alice</code>. This tag is used for <code>routes</code> in the <code>autoApprovers</code> section. The IPv4 route <code>192.168.0.0/24</code> is automatically approved once announced by a subnet router owned by the user <code>alice</code> and that also advertises the tag <code>tag:router</code>.</p> Subnet routers owned by alice and tagged with tag:router are automatically approved<pre><code>{\n  \"tagOwners\": {\n    \"tag:router\": [\"alice@\"]\n  },\n  \"autoApprovers\": {\n    \"routes\": {\n      \"192.168.0.0/24\": [\"tag:router\"]\n    }\n  },\n  \"acls\": [\n    // more rules\n  ]\n}\n</code></pre> <p>Advertise the route <code>192.168.0.0/24</code> from a subnet router that also advertises the tag <code>tag:router</code> when joining the tailnet:</p> <pre><code>$ sudo tailscale up --login-server &lt;YOUR_HEADSCALE_URL&gt; --advertise-tags tag:router --advertise-routes 192.168.0.0/24\n</code></pre> <p>Please see the official Tailscale documentation for more information on auto approvers.</p>"},{"location":"ref/routes/#exit-node","title":"Exit node","text":"<p>The setup of an exit node requires double opt-in, once from an exit node and once on the control server to allow its use within the tailnet. Optionally, use <code>autoApprovers</code> to automatically approve an exit node.</p>"},{"location":"ref/routes/#setup-an-exit-node","title":"Setup an exit node","text":""},{"location":"ref/routes/#configure-a-node-as-exit-node","title":"Configure a node as exit node","text":"<p>Register a node and make it advertise itself as an exit node:</p> <pre><code>$ sudo tailscale up --login-server &lt;YOUR_HEADSCALE_URL&gt; --advertise-exit-node\n</code></pre> <p>If the node is already registered, it can advertise exit capabilities like this:</p> <pre><code>$ sudo tailscale set --advertise-exit-node\n</code></pre> <p>Finally, enable IP forwarding to route traffic.</p>"},{"location":"ref/routes/#enable-the-exit-node-on-the-control-server","title":"Enable the exit node on the control server","text":"<p>The routes of a tailnet can be displayed with the <code>headscale nodes list-routes</code> command. An exit node can be recognized by its announced routes: <code>0.0.0.0/0</code> for IPv4 and <code>::/0</code> for IPv6. The exit node with the hostname <code>myexit</code> is already available, but needs to be approved:</p> <pre><code>$ headscale nodes list-routes\nID | Hostname | Approved | Available       | Serving (Primary)\n1  | myexit   |          | 0.0.0.0/0, ::/0 |\n</code></pre> <p>For exit nodes, it is sufficient to approve either the IPv4 or IPv6 route. The other will be approved automatically.</p> <pre><code>$ headscale nodes approve-routes --identifier 1 --routes 0.0.0.0/0\nNode updated\n</code></pre> <p>The node <code>myexit</code> is now approved as exit node for the tailnet:</p> <pre><code>$ headscale nodes list-routes\nID | Hostname | Approved        | Available       | Serving (Primary)\n1  | myexit   | 0.0.0.0/0, ::/0 | 0.0.0.0/0, ::/0 | 0.0.0.0/0, ::/0\n</code></pre>"},{"location":"ref/routes/#use-the-exit-node","title":"Use the exit node","text":"<p>The exit node can now be used on a node with:</p> <pre><code>$ sudo tailscale set --exit-node myexit\n</code></pre> <p>Please refer to the official Tailscale documentation for how to use an exit node on different operating systems.</p>"},{"location":"ref/routes/#restrict-the-use-of-an-exit-node-with-acl","title":"Restrict the use of an exit node with ACL","text":"<p>An exit node is offered to all nodes in a tailnet. By default, without an ACL enabled, all nodes in a tailnet can select and use an exit node. Configure <code>autogroup:internet</code> in an ACL rule to restrict who can use any of the available exit nodes.</p> Example use of autogroup:internet<pre><code>{\n  \"acls\": [\n    {\n      \"action\": \"accept\",\n      \"src\": [\"...\"],\n      \"dst\": [\"autogroup:internet:*\"]\n    }\n  ]\n}\n</code></pre>"},{"location":"ref/routes/#automatically-approve-an-exit-node-with-auto-approvers","title":"Automatically approve an exit node with auto approvers","text":"<p>The initial setup of an exit node usually requires manual approval on the control server before it can be used by a node in a tailnet. Headscale supports the <code>autoApprovers</code> section of an ACL to automate the approval of a new exit node as soon as it joins the tailnet.</p> <p>The ACL snippet below defines the tag <code>tag:exit</code> owned by the user <code>alice</code>. This tag is used for <code>exitNode</code> in the <code>autoApprovers</code> section. A new exit node which is owned by the user <code>alice</code> and that also advertises the tag <code>tag:exit</code> is automatically approved:</p> Exit nodes owned by alice and tagged with tag:exit are automatically approved<pre><code>{\n  \"tagOwners\": {\n    \"tag:exit\": [\"alice@\"]\n  },\n  \"autoApprovers\": {\n    \"exitNode\": [\"tag:exit\"]\n  },\n  \"acls\": [\n    // more rules\n  ]\n}\n</code></pre> <p>Advertise a node as exit node and also advertise the tag <code>tag:exit</code> when joining the tailnet:</p> <pre><code>$ sudo tailscale up --login-server &lt;YOUR_HEADSCALE_URL&gt; --advertise-tags tag:exit --advertise-exit-node\n</code></pre> <p>Please see the official Tailscale documentation for more information on auto approvers.</p>"},{"location":"ref/routes/#high-availability","title":"High availability","text":"<p>Headscale has limited support for high availability routing. Multiple subnet routers with overlapping routes or multiple exit nodes can be used to provide high availability for users. If one router node goes offline, another one can serve the same routes to clients. Please see the official Tailscale documentation on high availability for details.</p> <p>Bug</p> <p>In certain situations it might take up to 16 minutes for Headscale to detect a node as offline. A failover node might not be selected fast enough, if such a node is used as subnet router or exit node causing service interruptions for clients. See issue 2129 for more information.</p>"},{"location":"ref/routes/#troubleshooting","title":"Troubleshooting","text":""},{"location":"ref/routes/#enable-ip-forwarding","title":"Enable IP forwarding","text":"<p>A subnet router or exit node is routing traffic on behalf of other nodes and thus requires IP forwarding. Check the official Tailscale documentation for how to enable IP forwarding.</p>"},{"location":"ref/tls/","title":"Running the service via TLS (optional)","text":""},{"location":"ref/tls/#bring-your-own-certificate","title":"Bring your own certificate","text":"<p>Headscale can be configured to expose its web service via TLS. To configure the certificate and key file manually, set the <code>tls_cert_path</code> and <code>tls_key_path</code> configuration parameters. If the path is relative, it will be interpreted as relative to the directory the configuration file was read from.</p> config.yaml<pre><code>tls_cert_path: \"\"\ntls_key_path: \"\"\n</code></pre> <p>The certificate should contain the full chain, else some clients, like the Tailscale Android client, will reject it.</p>"},{"location":"ref/tls/#lets-encrypt-acme","title":"Let's Encrypt / ACME","text":"<p>To get a certificate automatically via Let's Encrypt, set <code>tls_letsencrypt_hostname</code> to the desired certificate hostname. This name must resolve to the IP address(es) headscale is reachable on (i.e., it must correspond to the <code>server_url</code> configuration parameter). The certificate and Let's Encrypt account credentials will be stored in the directory configured in <code>tls_letsencrypt_cache_dir</code>. If the path is relative, it will be interpreted as relative to the directory the configuration file was read from.</p> config.yaml<pre><code>tls_letsencrypt_hostname: \"\"\ntls_letsencrypt_listen: \":http\"\ntls_letsencrypt_cache_dir: \".cache\"\ntls_letsencrypt_challenge_type: HTTP-01\n</code></pre>"},{"location":"ref/tls/#challenge-types","title":"Challenge types","text":"<p>Headscale only supports two values for <code>tls_letsencrypt_challenge_type</code>: <code>HTTP-01</code> (default) and <code>TLS-ALPN-01</code>.</p>"},{"location":"ref/tls/#http-01","title":"HTTP-01","text":"<p>For <code>HTTP-01</code>, headscale must be reachable on port 80 for the Let's Encrypt automated validation, in addition to whatever port is configured in <code>listen_addr</code>. By default, headscale listens on port 80 on all local IPs for Let's Encrypt automated validation.</p> <p>If you need to change the ip and/or port used by headscale for the Let's Encrypt validation process, set <code>tls_letsencrypt_listen</code> to the appropriate value. This can be handy if you are running headscale as a non-root user (or can't run <code>setcap</code>). Keep in mind, however, that Let's Encrypt will only connect to port 80 for the validation callback, so if you change <code>tls_letsencrypt_listen</code> you will also need to configure something else (e.g. a firewall rule) to forward the traffic from port 80 to the ip:port combination specified in <code>tls_letsencrypt_listen</code>.</p>"},{"location":"ref/tls/#tls-alpn-01","title":"TLS-ALPN-01","text":"<p>For <code>TLS-ALPN-01</code>, headscale listens on the ip:port combination defined in <code>listen_addr</code>. Let's Encrypt will only connect to port 443 for the validation callback, so if <code>listen_addr</code> is not set to port 443, something else (e.g. a firewall rule) will be required to forward the traffic from port 443 to the ip:port combination specified in <code>listen_addr</code>.</p>"},{"location":"ref/tls/#technical-description","title":"Technical description","text":"<p>Headscale uses autocert, a Golang library providing ACME protocol verification, to facilitate certificate renewals via Let's Encrypt. Certificates will be renewed automatically, and the following can be expected:</p> <ul> <li>Certificates provided from Let's Encrypt have a validity of 3 months from date issued.</li> <li>Renewals are only attempted by headscale when 30 days or less remains until certificate expiry.</li> <li>Renewal attempts by autocert are triggered at a random interval of 30-60 minutes.</li> <li>No log output is generated when renewals are skipped, or successful.</li> </ul>"},{"location":"ref/tls/#checking-certificate-expiry","title":"Checking certificate expiry","text":"<p>If you want to validate that certificate renewal completed successfully, this can be done either manually, or through external monitoring software. Two examples of doing this manually:</p> <ol> <li>Open the URL for your headscale server in your browser of choice, and manually inspecting the expiry date of the certificate you receive.</li> <li>Or, check remotely from CLI using <code>openssl</code>:</li> </ol> <pre><code>$ openssl s_client -servername [hostname] -connect [hostname]:443 | openssl x509 -noout -dates\n(...)\nnotBefore=Feb  8 09:48:26 2024 GMT\nnotAfter=May  8 09:48:25 2024 GMT\n</code></pre>"},{"location":"ref/tls/#log-output-from-the-autocert-library","title":"Log output from the autocert library","text":"<p>As these log lines are from the autocert library, they are not strictly generated by headscale itself.</p> <pre><code>acme/autocert: missing server name\n</code></pre> <p>Likely caused by an incoming connection that does not specify a hostname, for example a <code>curl</code> request directly against the IP of the server, or an unexpected hostname.</p> <pre><code>acme/autocert: host \"[foo]\" not configured in HostWhitelist\n</code></pre> <p>Similarly to the above, this likely indicates an invalid incoming request for an incorrect hostname, commonly just the IP itself.</p> <p>The source code for autocert can be found here</p>"},{"location":"ref/integration/reverse-proxy/","title":"Running headscale behind a reverse proxy","text":"<p>Community documentation</p> <p>This page is not actively maintained by the headscale authors and is written by community members. It is not verified by headscale developers.</p> <p>It might be outdated and it might miss necessary steps.</p> <p>Running headscale behind a reverse proxy is useful when running multiple applications on the same server, and you want to reuse the same external IP and port - usually tcp/443 for HTTPS.</p>"},{"location":"ref/integration/reverse-proxy/#websockets","title":"WebSockets","text":"<p>The reverse proxy MUST be configured to support WebSockets to communicate with Tailscale clients.</p> <p>WebSockets support is also required when using the headscale embedded DERP server. In this case, you will also need to expose the UDP port used for STUN (by default, udp/3478). Please check our config-example.yaml.</p>"},{"location":"ref/integration/reverse-proxy/#cloudflare","title":"Cloudflare","text":"<p>Running headscale behind a cloudflare proxy or cloudflare tunnel is not supported and will not work as Cloudflare does not support WebSocket POSTs as required by the Tailscale protocol. See this issue</p>"},{"location":"ref/integration/reverse-proxy/#tls","title":"TLS","text":"<p>Headscale can be configured not to use TLS, leaving it to the reverse proxy to handle. Add the following configuration values to your headscale config file.</p> config.yaml<pre><code>server_url: https://&lt;YOUR_SERVER_NAME&gt; # This should be the FQDN at which headscale will be served\nlisten_addr: 0.0.0.0:8080\nmetrics_listen_addr: 0.0.0.0:9090\ntls_cert_path: \"\"\ntls_key_path: \"\"\n</code></pre>"},{"location":"ref/integration/reverse-proxy/#nginx","title":"nginx","text":"<p>The following example configuration can be used in your nginx setup, substituting values as necessary. <code>&lt;IP:PORT&gt;</code> should be the IP address and port where headscale is running. In most cases, this will be <code>http://localhost:8080</code>.</p> nginx.conf<pre><code>map $http_upgrade $connection_upgrade {\n    default      upgrade;\n    ''           close;\n}\n\nserver {\n    listen 80;\n    listen [::]:80;\n\n    listen 443      ssl http2;\n    listen [::]:443 ssl http2;\n\n    server_name &lt;YOUR_SERVER_NAME&gt;;\n\n    ssl_certificate &lt;PATH_TO_CERT&gt;;\n    ssl_certificate_key &lt;PATH_CERT_KEY&gt;;\n    ssl_protocols TLSv1.2 TLSv1.3;\n\n    location / {\n        proxy_pass http://&lt;IP:PORT&gt;;\n        proxy_http_version 1.1;\n        proxy_set_header Upgrade $http_upgrade;\n        proxy_set_header Connection $connection_upgrade;\n        proxy_set_header Host $server_name;\n        proxy_redirect http:// https://;\n        proxy_buffering off;\n        proxy_set_header X-Real-IP $remote_addr;\n        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header X-Forwarded-Proto $scheme;\n        add_header Strict-Transport-Security \"max-age=15552000; includeSubDomains\" always;\n    }\n}\n</code></pre>"},{"location":"ref/integration/reverse-proxy/#istioenvoy","title":"istio/envoy","text":"<p>If you using Istio ingressgateway or Envoy as reverse proxy, there are some tips for you. If not set, you may see some debug log in proxy as below:</p> <pre><code>Sending local reply with details upgrade_failed\n</code></pre>"},{"location":"ref/integration/reverse-proxy/#envoy","title":"Envoy","text":"<p>You need to add a new upgrade_type named <code>tailscale-control-protocol</code>. see details</p>"},{"location":"ref/integration/reverse-proxy/#istio","title":"Istio","text":"<p>Same as envoy, we can use <code>EnvoyFilter</code> to add upgrade_type.</p> <pre><code>apiVersion: networking.istio.io/v1alpha3\nkind: EnvoyFilter\nmetadata:\n  name: headscale-behind-istio-ingress\n  namespace: istio-system\nspec:\n  configPatches:\n    - applyTo: NETWORK_FILTER\n      match:\n        listener:\n          filterChain:\n            filter:\n              name: envoy.filters.network.http_connection_manager\n      patch:\n        operation: MERGE\n        value:\n          typed_config:\n            \"@type\": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager\n            upgrade_configs:\n              - upgrade_type: tailscale-control-protocol\n</code></pre>"},{"location":"ref/integration/reverse-proxy/#caddy","title":"Caddy","text":"<p>The following Caddyfile is all that is necessary to use Caddy as a reverse proxy for headscale, in combination with the <code>config.yaml</code> specifications above to disable headscale's built in TLS. Replace values as necessary - <code>&lt;YOUR_SERVER_NAME&gt;</code> should be the FQDN at which headscale will be served, and <code>&lt;IP:PORT&gt;</code> should be the IP address and port where headscale is running. In most cases, this will be <code>localhost:8080</code>.</p> Caddyfile<pre><code>&lt;YOUR_SERVER_NAME&gt; {\n    reverse_proxy &lt;IP:PORT&gt;\n}\n</code></pre> <p>Caddy v2 will automatically provision a certificate for your domain/subdomain, force HTTPS, and proxy websockets - no further configuration is necessary.</p> <p>For a slightly more complex configuration which utilizes Docker containers to manage Caddy, headscale, and Headscale-UI, Guru Computing's guide is an excellent reference.</p>"},{"location":"ref/integration/reverse-proxy/#apache","title":"Apache","text":"<p>The following minimal Apache config will proxy traffic to the headscale instance on <code>&lt;IP:PORT&gt;</code>. Note that <code>upgrade=any</code> is required as a parameter for <code>ProxyPass</code> so that WebSockets traffic whose <code>Upgrade</code> header value is not equal to <code>WebSocket</code> (i. e. Tailscale Control Protocol) is forwarded correctly. See the Apache docs for more information on this.</p> apache.conf<pre><code>&lt;VirtualHost *:443&gt;\n    ServerName &lt;YOUR_SERVER_NAME&gt;\n\n    ProxyPreserveHost On\n    ProxyPass / http://&lt;IP:PORT&gt;/ upgrade=any\n\n    SSLEngine On\n    SSLCertificateFile &lt;PATH_TO_CERT&gt;\n    SSLCertificateKeyFile &lt;PATH_CERT_KEY&gt;\n&lt;/VirtualHost&gt;\n</code></pre>"},{"location":"ref/integration/tools/","title":"Tools related to headscale","text":"<p>Community contributions</p> <p>This page contains community contributions. The projects listed here are not maintained by the headscale authors and are written by community members.</p> <p>This page collects third-party tools, client libraries, and scripts related to headscale.</p> Name Repository Link Description tailscale-manager Github Dynamically manage Tailscale route advertisements headscalebacktosqlite Github Migrate headscale from PostgreSQL back to SQLite headscale-pf Github Populates user groups based on user groups in Jumpcloud or Authentik headscale-client-go Github A Go client implementation for the Headscale HTTP API."},{"location":"ref/integration/web-ui/","title":"Web interfaces for headscale","text":"<p>Community contributions</p> <p>This page contains community contributions. The projects listed here are not maintained by the headscale authors and are written by community members.</p> <p>Headscale doesn't provide a built-in web interface but users may pick one from the available options.</p> Name Repository Link Description headscale-ui Github A web frontend for the headscale Tailscale-compatible coordination server HeadscaleUi GitHub A static headscale admin ui, no backend environment required Headplane GitHub An advanced Tailscale inspired frontend for headscale headscale-admin Github Headscale-Admin is meant to be a simple, modern web interface for headscale ouroboros Github Ouroboros is designed for users to manage their own devices, rather than for admins unraid-headscale-admin Github A simple headscale admin UI for Unraid, it offers Local (<code>docker exec</code>) and API Mode headscale-console Github WebAssembly-based client supporting SSH, VNC and RDP with optional self-service capabilities <p>You can ask for support on our Discord server in the \"web-interfaces\" channel.</p>"},{"location":"setup/requirements/","title":"Requirements","text":"<p>Headscale should just work as long as the following requirements are met:</p> <ul> <li>A server with a public IP address for headscale. A dual-stack setup with a public IPv4 and a public IPv6 address is   recommended.</li> <li>Headscale is served via HTTPS on port 443<sup>1</sup>.</li> <li>A reasonably modern Linux or BSD based operating system.</li> <li>A dedicated local user account to run headscale.</li> <li>A little bit of command line knowledge to configure and operate headscale.</li> </ul>"},{"location":"setup/requirements/#assumptions","title":"Assumptions","text":"<p>The headscale documentation and the provided examples are written with a few assumptions in mind:</p> <ul> <li>Headscale is running as system service via a dedicated local user <code>headscale</code>.</li> <li>The configuration is loaded from <code>/etc/headscale/config.yaml</code>.</li> <li>SQLite is used as database.</li> <li>The data directory for headscale (used for private keys, ACLs, SQLite database, \u2026) is located in <code>/var/lib/headscale</code>.</li> <li>URLs and values that need to be replaced by the user are either denoted as <code>&lt;VALUE_TO_CHANGE&gt;</code> or use placeholder   values such as <code>headscale.example.com</code>.</li> </ul> <p>Please adjust to your local environment accordingly.</p> <ol> <li> <p>The Tailscale client assumes HTTPS on port 443 in certain situations. Serving headscale either via HTTP or via HTTPS on a port other than 443 is possible but sticking with HTTPS on port 443 is strongly recommended for production setups. See issue 2164 for more information.\u00a0\u21a9</p> </li> </ol>"},{"location":"setup/upgrade/","title":"Upgrade an existing installation","text":"<p>Update an existing headscale installation to a new version:</p> <ul> <li>Read the announcement on the GitHub releases page for the new   version. It lists the changes of the release along with possible breaking changes.</li> <li>Create a backup of your database.</li> <li>Update headscale to the new version, preferably by following the same installation method.</li> <li>Compare and update the configuration file.</li> <li>Restart headscale.</li> </ul>"},{"location":"setup/install/community/","title":"Community packages","text":"<p>Several Linux distributions and community members provide packages for headscale. Those packages may be used instead of the official releases provided by the headscale maintainers. Such packages offer improved integration for their targeted operating system and usually:</p> <ul> <li>setup a dedicated local user account to run headscale</li> <li>provide a default configuration</li> <li>install headscale as system service</li> </ul> <p>Community packages might be outdated</p> <p>The packages mentioned on this page might be outdated or unmaintained. Use the official releases to get the current stable version or to test pre-releases.</p> <p></p>"},{"location":"setup/install/community/#arch-linux","title":"Arch Linux","text":"<p>Arch Linux offers a package for headscale, install via:</p> <pre><code>pacman -S headscale\n</code></pre> <p>The AUR package <code>headscale-git</code> can be used to build the current development version.</p>"},{"location":"setup/install/community/#fedora-rhel-centos","title":"Fedora, RHEL, CentOS","text":"<p>A third-party repository for various RPM based distributions is available at: https://copr.fedorainfracloud.org/coprs/jonathanspw/headscale/. The site provides detailed setup and installation instructions.</p>"},{"location":"setup/install/community/#nix-nixos","title":"Nix, NixOS","text":"<p>A Nix package is available as: <code>headscale</code>. See the NixOS package site for installation details.</p>"},{"location":"setup/install/community/#gentoo","title":"Gentoo","text":"<pre><code>emerge --ask net-vpn/headscale\n</code></pre> <p>Gentoo specific documentation is available here.</p>"},{"location":"setup/install/community/#openbsd","title":"OpenBSD","text":"<p>Headscale is available in ports. The port installs headscale as system service with <code>rc.d</code> and provides usage instructions upon installation.</p> <pre><code>pkg_add headscale\n</code></pre>"},{"location":"setup/install/container/","title":"Running headscale in a container","text":"<p>Community documentation</p> <p>This page is not actively maintained by the headscale authors and is written by community members. It is not verified by headscale developers.</p> <p>It might be outdated and it might miss necessary steps.</p> <p>This documentation has the goal of showing a user how-to set up and run headscale in a container. A container runtime such as Docker or Podman is required. The container image can be found on Docker Hub and GitHub Container Registry. The container image URLs are:</p> <ul> <li>Docker Hub: <code>docker.io/headscale/headscale:&lt;VERSION&gt;</code></li> <li>GitHub Container Registry:   <code>ghcr.io/juanfont/headscale:&lt;VERSION&gt;</code></li> </ul>"},{"location":"setup/install/container/#configure-and-run-headscale","title":"Configure and run headscale","text":"<ol> <li> <p>Create a directory on the Docker host to store headscale's configuration and the SQLite database:</p> <pre><code>mkdir -p ./headscale/{config,lib,run}\ncd ./headscale\n</code></pre> </li> <li> <p>Download the example configuration for your chosen version and save it as: <code>$(pwd)/config/config.yaml</code>. Adjust the     configuration to suit your local environment. See Configuration for details.</p> </li> <li> <p>Start headscale from within the previously created <code>./headscale</code> directory:</p> <pre><code>docker run \\\n  --name headscale \\\n  --detach \\\n  --volume \"$(pwd)/config:/etc/headscale\" \\\n  --volume \"$(pwd)/lib:/var/lib/headscale\" \\\n  --volume \"$(pwd)/run:/var/run/headscale\" \\\n  --publish 127.0.0.1:8080:8080 \\\n  --publish 127.0.0.1:9090:9090 \\\n  docker.io/headscale/headscale:&lt;VERSION&gt; \\\n  serve\n</code></pre> <p>Note: use <code>0.0.0.0:8080:8080</code> instead of <code>127.0.0.1:8080:8080</code> if you want to expose the container externally.</p> <p>This command mounts the local directories inside the container, forwards port 8080 and 9090 out of the container so the headscale instance becomes available and then detaches so headscale runs in the background.</p> <p>A similar configuration for <code>docker-compose</code>:</p> docker-compose.yaml<pre><code>services:\n  headscale:\n    image: docker.io/headscale/headscale:&lt;VERSION&gt;\n    restart: unless-stopped\n    container_name: headscale\n    ports:\n      - \"127.0.0.1:8080:8080\"\n      - \"127.0.0.1:9090:9090\"\n    volumes:\n      # Please set &lt;HEADSCALE_PATH&gt; to the absolute path\n      # of the previously created headscale directory.\n      - &lt;HEADSCALE_PATH&gt;/config:/etc/headscale\n      - &lt;HEADSCALE_PATH&gt;/lib:/var/lib/headscale\n      - &lt;HEADSCALE_PATH&gt;/run:/var/run/headscale\n    command: serve\n</code></pre> </li> <li> <p>Verify headscale is running:</p> <p>Follow the container logs:</p> <pre><code>docker logs --follow headscale\n</code></pre> <p>Verify running containers:</p> <pre><code>docker ps\n</code></pre> <p>Verify headscale is available:</p> <pre><code>curl http://127.0.0.1:9090/metrics\n</code></pre> </li> <li> <p>Create a headscale user:</p> <pre><code>docker exec -it headscale \\\n  headscale users create myfirstuser\n</code></pre> </li> </ol>"},{"location":"setup/install/container/#register-a-machine-normal-login","title":"Register a machine (normal login)","text":"<p>On a client machine, execute the <code>tailscale up</code> command to login:</p> <pre><code>tailscale up --login-server YOUR_HEADSCALE_URL\n</code></pre> <p>To register a machine when running headscale in a container, take the headscale command and pass it to the container:</p> <pre><code>docker exec -it headscale \\\n  headscale nodes register --user myfirstuser --key &lt;YOUR_MACHINE_KEY&gt;\n</code></pre>"},{"location":"setup/install/container/#register-a-machine-using-a-pre-authenticated-key","title":"Register a machine using a pre authenticated key","text":"<p>Generate a key using the command line for the user with ID 1:</p> <pre><code>docker exec -it headscale \\\n  headscale preauthkeys create --user 1 --reusable --expiration 24h\n</code></pre> <p>This will return a pre-authenticated key that can be used to connect a node to headscale with the <code>tailscale up</code> command:</p> <pre><code>tailscale up --login-server &lt;YOUR_HEADSCALE_URL&gt; --authkey &lt;YOUR_AUTH_KEY&gt;\n</code></pre>"},{"location":"setup/install/container/#debugging-headscale-running-in-docker","title":"Debugging headscale running in Docker","text":"<p>The Headscale container image is based on a \"distroless\" image that does not contain a shell or any other debug tools. If you need to debug headscale running in the Docker container, you can use the <code>-debug</code> variant, for example <code>docker.io/headscale/headscale:x.x.x-debug</code>.</p>"},{"location":"setup/install/container/#running-the-debug-docker-container","title":"Running the debug Docker container","text":"<p>To run the debug Docker container, use the exact same commands as above, but replace <code>docker.io/headscale/headscale:x.x.x</code> with <code>docker.io/headscale/headscale:x.x.x-debug</code> (<code>x.x.x</code> is the version of headscale). The two containers are compatible with each other, so you can alternate between them.</p>"},{"location":"setup/install/container/#executing-commands-in-the-debug-container","title":"Executing commands in the debug container","text":"<p>The default command in the debug container is to run <code>headscale</code>, which is located at <code>/ko-app/headscale</code> inside the container.</p> <p>Additionally, the debug container includes a minimalist Busybox shell.</p> <p>To launch a shell in the container, use:</p> <pre><code>docker run -it docker.io/headscale/headscale:x.x.x-debug sh\n</code></pre> <p>You can also execute commands directly, such as <code>ls /ko-app</code> in this example:</p> <pre><code>docker run docker.io/headscale/headscale:x.x.x-debug ls /ko-app\n</code></pre> <p>Using <code>docker exec -it</code> allows you to run commands in an existing container.</p>"},{"location":"setup/install/official/","title":"Official releases","text":"<p>Official releases for headscale are available as binaries for various platforms and DEB packages for Debian and Ubuntu. Both are available on the GitHub releases page.</p>"},{"location":"setup/install/official/#using-packages-for-debianubuntu-recommended","title":"Using packages for Debian/Ubuntu (recommended)","text":"<p>It is recommended to use our DEB packages to install headscale on a Debian based system as those packages configure a local user to run headscale, provide a default configuration and ship with a systemd service file. Supported distributions are Ubuntu 22.04 or newer, Debian 11 or newer.</p> <ol> <li> <p>Download the latest headscale package for your platform (<code>.deb</code> for Ubuntu and Debian).</p> <pre><code>HEADSCALE_VERSION=\"\" # See above URL for latest version, e.g. \"X.Y.Z\" (NOTE: do not add the \"v\" prefix!)\nHEADSCALE_ARCH=\"\" # Your system architecture, e.g. \"amd64\"\nwget --output-document=headscale.deb \\\n \"https://github.com/juanfont/headscale/releases/download/v${HEADSCALE_VERSION}/headscale_${HEADSCALE_VERSION}_linux_${HEADSCALE_ARCH}.deb\"\n</code></pre> </li> <li> <p>Install headscale:</p> <pre><code>sudo apt install ./headscale.deb\n</code></pre> </li> <li> <p>Configure headscale by editing the configuration file:</p> <pre><code>sudo nano /etc/headscale/config.yaml\n</code></pre> </li> <li> <p>Enable and start the headscale service:</p> <pre><code>sudo systemctl enable --now headscale\n</code></pre> </li> <li> <p>Verify that headscale is running as intended:</p> <pre><code>sudo systemctl status headscale\n</code></pre> </li> </ol>"},{"location":"setup/install/official/#using-standalone-binaries-advanced","title":"Using standalone binaries (advanced)","text":"<p>Advanced</p> <p>This installation method is considered advanced as one needs to take care of the local user and the systemd service themselves. If possible, use the DEB packages or a community package instead.</p> <p>This section describes the installation of headscale according to the Requirements and assumptions. Headscale is run by a dedicated local user and the service itself is managed by systemd.</p> <ol> <li> <p>Download the latest <code>headscale</code> binary from GitHub's release page:</p> <pre><code>sudo wget --output-document=/usr/local/bin/headscale \\\nhttps://github.com/juanfont/headscale/releases/download/v&lt;HEADSCALE VERSION&gt;/headscale_&lt;HEADSCALE VERSION&gt;_linux_&lt;ARCH&gt;\n</code></pre> </li> <li> <p>Make <code>headscale</code> executable:</p> <pre><code>sudo chmod +x /usr/local/bin/headscale\n</code></pre> </li> <li> <p>Add a dedicated local user to run headscale:</p> <pre><code>sudo useradd \\\n --create-home \\\n --home-dir /var/lib/headscale/ \\\n --system \\\n --user-group \\\n --shell /usr/sbin/nologin \\\n headscale\n</code></pre> </li> <li> <p>Download the example configuration for your chosen version and save it as: <code>/etc/headscale/config.yaml</code>. Adjust the     configuration to suit your local environment. See Configuration for details.</p> <pre><code>sudo mkdir -p /etc/headscale\nsudo nano /etc/headscale/config.yaml\n</code></pre> </li> <li> <p>Copy headscale's systemd service file     to <code>/etc/systemd/system/headscale.service</code> and adjust it to suit your local setup. The following parameters likely need     to be modified: <code>ExecStart</code>, <code>WorkingDirectory</code>, <code>ReadWritePaths</code>.</p> </li> <li> <p>In <code>/etc/headscale/config.yaml</code>, override the default <code>headscale</code> unix socket with a path that is writable by the     <code>headscale</code> user or group:</p> config.yaml<pre><code>unix_socket: /var/run/headscale/headscale.sock\n</code></pre> </li> <li> <p>Reload systemd to load the new configuration file:</p> <pre><code>systemctl daemon-reload\n</code></pre> </li> <li> <p>Enable and start the new headscale service:</p> <pre><code>systemctl enable --now headscale\n</code></pre> </li> <li> <p>Verify that headscale is running as intended:</p> <pre><code>systemctl status headscale\n</code></pre> </li> </ol>"},{"location":"setup/install/source/","title":"Build from source","text":"<p>Community documentation</p> <p>This page is not actively maintained by the headscale authors and is written by community members. It is not verified by headscale developers.</p> <p>It might be outdated and it might miss necessary steps.</p> <p>Headscale can be built from source using the latest version of Go and Buf (Protobuf generator). See the Contributing section in the GitHub README for more information.</p>"},{"location":"setup/install/source/#openbsd","title":"OpenBSD","text":""},{"location":"setup/install/source/#install-from-source","title":"Install from source","text":"<pre><code># Install prerequisites\npkg_add go git\n\ngit clone https://github.com/juanfont/headscale.git\n\ncd headscale\n\n# optionally checkout a release\n# option a. you can find official release at https://github.com/juanfont/headscale/releases/latest\n# option b. get latest tag, this may be a beta release\nlatestTag=$(git describe --tags `git rev-list --tags --max-count=1`)\n\ngit checkout $latestTag\n\ngo build -ldflags=\"-s -w -X github.com/juanfont/headscale/hscontrol/types.Version=$latestTag\" -X github.com/juanfont/headscale/hscontrol/types.GitCommitHash=HASH\" github.com/juanfont/headscale\n\n# make it executable\nchmod a+x headscale\n\n# copy it to /usr/local/sbin\ncp headscale /usr/local/sbin\n</code></pre>"},{"location":"setup/install/source/#install-from-source-via-cross-compile","title":"Install from source via cross compile","text":"<pre><code># Install prerequisites\n# 1. go v1.20+: headscale newer than 0.21 needs go 1.20+ to compile\n# 2. gmake: Makefile in the headscale repo is written in GNU make syntax\n\ngit clone https://github.com/juanfont/headscale.git\n\ncd headscale\n\n# optionally checkout a release\n# option a. you can find official release at https://github.com/juanfont/headscale/releases/latest\n# option b. get latest tag, this may be a beta release\nlatestTag=$(git describe --tags `git rev-list --tags --max-count=1`)\n\ngit checkout $latestTag\n\nmake build GOOS=openbsd\n\n# copy headscale to openbsd machine and put it in /usr/local/sbin\n</code></pre>"},{"location":"usage/getting-started/","title":"Getting started","text":"<p>This page helps you get started with headscale and provides a few usage examples for the headscale command line tool <code>headscale</code>.</p> <p>Prerequisites</p> <ul> <li>Headscale is installed and running as system service. Read the setup section for   installation instructions.</li> <li>The configuration file exists and is adjusted to suit your environment, see   Configuration for details.</li> <li>Headscale is reachable from the Internet. Verify this by opening client specific setup instructions in your   browser, e.g. https://headscale.example.com/windows</li> <li>The Tailscale client is installed, see Client and operating system support for more   information.</li> </ul>"},{"location":"usage/getting-started/#getting-help","title":"Getting help","text":"<p>The <code>headscale</code> command line tool provides built-in help. To show available commands along with their arguments and options, run:</p> NativeContainer <pre><code># Show help\nheadscale help\n\n# Show help for a specific command\nheadscale &lt;COMMAND&gt; --help\n</code></pre> <pre><code># Show help\ndocker exec -it headscale \\\n  headscale help\n\n# Show help for a specific command\ndocker exec -it headscale \\\n  headscale &lt;COMMAND&gt; --help\n</code></pre>"},{"location":"usage/getting-started/#manage-headscale-users","title":"Manage headscale users","text":"<p>In headscale, a node (also known as machine or device) is always assigned to a headscale user. Such a headscale user may have many nodes assigned to them and can be managed with the <code>headscale users</code> command. Invoke the built-in help for more information: <code>headscale users --help</code>.</p>"},{"location":"usage/getting-started/#create-a-headscale-user","title":"Create a headscale user","text":"NativeContainer <pre><code>headscale users create &lt;USER&gt;\n</code></pre> <pre><code>docker exec -it headscale \\\n  headscale users create &lt;USER&gt;\n</code></pre>"},{"location":"usage/getting-started/#list-existing-headscale-users","title":"List existing headscale users","text":"NativeContainer <pre><code>headscale users list\n</code></pre> <pre><code>docker exec -it headscale \\\n  headscale users list\n</code></pre>"},{"location":"usage/getting-started/#register-a-node","title":"Register a node","text":"<p>One has to register a node first to use headscale as coordination with Tailscale. The following examples work for the Tailscale client on Linux/BSD operating systems. Alternatively, follow the instructions to connect Android, Apple or Windows devices.</p>"},{"location":"usage/getting-started/#normal-interactive-login","title":"Normal, interactive login","text":"<p>On a client machine, run the <code>tailscale up</code> command and provide the FQDN of your headscale instance as argument:</p> <pre><code>tailscale up --login-server &lt;YOUR_HEADSCALE_URL&gt;\n</code></pre> <p>Usually, a browser window with further instructions is opened and contains the value for <code>&lt;YOUR_MACHINE_KEY&gt;</code>. Approve and register the node on your headscale server:</p> NativeContainer <pre><code>headscale nodes register --user &lt;USER&gt; --key &lt;YOUR_MACHINE_KEY&gt;\n</code></pre> <pre><code>docker exec -it headscale \\\n  headscale nodes register --user &lt;USER&gt; --key &lt;YOUR_MACHINE_KEY&gt;\n</code></pre>"},{"location":"usage/getting-started/#using-a-preauthkey","title":"Using a preauthkey","text":"<p>It is also possible to generate a preauthkey and register a node non-interactively. First, generate a preauthkey on the headscale instance. By default, the key is valid for one hour and can only be used once (see <code>headscale preauthkeys --help</code> for other options):</p> NativeContainer <pre><code>headscale preauthkeys create --user &lt;USER_ID&gt;\n</code></pre> <pre><code>docker exec -it headscale \\\n  headscale preauthkeys create --user &lt;USER_ID&gt;\n</code></pre> <p>The command returns the preauthkey on success which is used to connect a node to the headscale instance via the <code>tailscale up</code> command:</p> <pre><code>tailscale up --login-server &lt;YOUR_HEADSCALE_URL&gt; --authkey &lt;YOUR_AUTH_KEY&gt;\n</code></pre>"},{"location":"usage/connect/android/","title":"Connecting an Android client","text":"<p>This documentation has the goal of showing how a user can use the official Android Tailscale client with headscale.</p>"},{"location":"usage/connect/android/#installation","title":"Installation","text":"<p>Install the official Tailscale Android client from the Google Play Store or F-Droid.</p>"},{"location":"usage/connect/android/#configuring-the-headscale-url","title":"Configuring the headscale URL","text":"<ul> <li>Open the app and select the settings menu in the upper-right corner</li> <li>Tap on <code>Accounts</code></li> <li>In the kebab menu icon (three dots) in the upper-right corner select <code>Use an alternate server</code></li> <li>Enter your server URL (e.g <code>https://headscale.example.com</code>) and follow the instructions</li> </ul>"},{"location":"usage/connect/apple/","title":"Connecting an Apple client","text":"<p>This documentation has the goal of showing how a user can use the official iOS and macOS Tailscale clients with headscale.</p> <p>Instructions on your headscale instance</p> <p>An endpoint with information on how to connect your Apple device is also available at <code>/apple</code> on your running instance.</p>"},{"location":"usage/connect/apple/#ios","title":"iOS","text":""},{"location":"usage/connect/apple/#installation","title":"Installation","text":"<p>Install the official Tailscale iOS client from the App Store.</p>"},{"location":"usage/connect/apple/#configuring-the-headscale-url","title":"Configuring the headscale URL","text":"<ul> <li>Open the Tailscale app</li> <li>Click the account icon in the top-right corner and select <code>Log in\u2026</code>.</li> <li>Tap the top-right options menu button and select <code>Use custom coordination server</code>.</li> <li>Enter your instance url (e.g <code>https://headscale.example.com</code>)</li> <li>Enter your credentials and log in. Headscale should now be working on your iOS device.</li> </ul>"},{"location":"usage/connect/apple/#macos","title":"macOS","text":""},{"location":"usage/connect/apple/#installation_1","title":"Installation","text":"<p>Choose one of the available Tailscale clients for macOS and install it.</p>"},{"location":"usage/connect/apple/#configuring-the-headscale-url_1","title":"Configuring the headscale URL","text":""},{"location":"usage/connect/apple/#command-line","title":"Command line","text":"<p>Use Tailscale's login command to connect with your headscale instance (e.g <code>https://headscale.example.com</code>):</p> <pre><code>tailscale login --login-server &lt;YOUR_HEADSCALE_URL&gt;\n</code></pre>"},{"location":"usage/connect/apple/#gui","title":"GUI","text":"<ul> <li>Option + Click the Tailscale icon in the menu and hover over the Debug menu</li> <li>Under <code>Custom Login Server</code>, select <code>Add Account...</code></li> <li>Enter the URL of your headscale instance (e.g <code>https://headscale.example.com</code>) and press <code>Add Account</code></li> <li>Follow the login procedure in the browser</li> </ul>"},{"location":"usage/connect/apple/#tvos","title":"tvOS","text":""},{"location":"usage/connect/apple/#installation_2","title":"Installation","text":"<p>Install the official Tailscale tvOS client from the App Store.</p> <p>Danger</p> <p>Don't open the Tailscale App after installation!</p>"},{"location":"usage/connect/apple/#configuring-the-headscale-url_2","title":"Configuring the headscale URL","text":"<ul> <li>Open Settings (the Apple tvOS settings) &gt; Apps &gt; Tailscale</li> <li>Under <code>ALTERNATE COORDINATION SERVER URL</code>, select <code>URL</code></li> <li>Enter the URL of your headscale instance (e.g <code>https://headscale.example.com</code>) and press <code>OK</code></li> <li>Return to the tvOS Home screen</li> <li>Open Tailscale</li> <li>Click the button <code>Install VPN configuration</code> and confirm the appearing popup by clicking the <code>Allow</code> button</li> <li>Scan the QR code and follow the login procedure</li> </ul>"},{"location":"usage/connect/windows/","title":"Connecting a Windows client","text":"<p>This documentation has the goal of showing how a user can use the official Windows Tailscale client with headscale.</p> <p>Instructions on your headscale instance</p> <p>An endpoint with information on how to connect your Windows device is also available at <code>/windows</code> on your running instance.</p>"},{"location":"usage/connect/windows/#installation","title":"Installation","text":"<p>Download the Official Windows Client and install it.</p>"},{"location":"usage/connect/windows/#configuring-the-headscale-url","title":"Configuring the headscale URL","text":"<p>Open a Command Prompt or Powershell and use Tailscale's login command to connect with your headscale instance (e.g <code>https://headscale.example.com</code>):</p> <pre><code>tailscale login --login-server &lt;YOUR_HEADSCALE_URL&gt;\n</code></pre> <p>Follow the instructions in the opened browser window to finish the configuration.</p>"},{"location":"usage/connect/windows/#troubleshooting","title":"Troubleshooting","text":""},{"location":"usage/connect/windows/#unattended-mode","title":"Unattended mode","text":"<p>By default, Tailscale's Windows client is only running when the user is logged in. If you want to keep Tailscale running all the time, please enable \"Unattended mode\":</p> <ul> <li>Click on the Tailscale tray icon and select <code>Preferences</code></li> <li>Enable <code>Run unattended</code></li> <li>Confirm the \"Unattended mode\" message</li> </ul> <p>See also Keep Tailscale running when I'm not logged in to my computer</p>"},{"location":"usage/connect/windows/#failing-node-registration","title":"Failing node registration","text":"<p>If you are seeing repeated messages like:</p> <pre><code>[GIN] 2022/02/10 - 16:39:34 | 200 |    1.105306ms |       127.0.0.1 | POST     \"/machine/redacted\"\n</code></pre> <p>in your headscale output, turn on <code>DEBUG</code> logging and look for:</p> <pre><code>2022-02-11T00:59:29Z DBG Machine registration has expired. Sending a authurl to register machine=redacted\n</code></pre> <p>This typically means that the registry keys above was not set appropriately.</p> <p>To reset and try again, it is important to do the following:</p> <ol> <li>Shut down the Tailscale service (or the client running in the tray)</li> <li>Delete Tailscale Application data folder, located at <code>C:\\Users\\&lt;USERNAME&gt;\\AppData\\Local\\Tailscale</code> and try to connect again.</li> <li>Ensure the Windows node is deleted from headscale (to ensure fresh setup)</li> <li>Start Tailscale on the Windows machine and retry the login.</li> </ol>"}]}